import * as _shared_clients_user_controlled_wallets from './clients/user-controlled-wallets';
import { TokenBlockchain, UserControlledWalletsClient, Blockchain, MetadataField, AccountType, FeeLevel, EstimateContractExecutionTransactionFeeRequestBlockchain, GetTransactionTxTypeEnum, ListTransactionsOperationEnum, ListTransactionsStateEnum, ListTransactionsTxTypeEnum, ListUsersPinStatusEnum, ListUsersSecurityQuestionStatusEnum, ListUserChallengesStatusEnum, UserTokenResponseData } from './clients/user-controlled-wallets';
export { AccountType, Balance, Blockchain, ChallengeStatusEnum, ChallengeTypeEnum, CustodyType, EndUserSecurityQuestionStatusEnum, EndUserStatus, EstimateContractExecutionTransactionFeeRequestBlockchain, FeeLevel, GetTransactionTxTypeEnum, ListTransactionsOperationEnum, ListTransactionsStateEnum, ListTransactionsTxTypeEnum, ListUserChallengesStatusEnum, ListUsersPinStatusEnum, ListUsersSecurityQuestionStatusEnum, ListWalletBalanceStandardEnum, ListWalletNftsStandardEnum, Operation, PinStatus, TokenBlockchain, TokenStandard, TransactionState, TransactionType, WalletState } from './clients/user-controlled-wallets';
import * as _shared_core from './clients/core';
import { APIParams as APIParams$1, ClientParams as ClientParams$1, WithIdempotencyKey, FeeConfiguration, Pagination } from './clients/core';
import * as axios from 'axios';

/**
 * Represents input parameters for identifying a user using a JWT token.
 */
interface UserTokenInput {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    userId?: never;
}
/**
 * Represents input parameters for identifying a user using their system-generated unique identifier.
 */
interface UserIdInput {
    userToken?: never;
    /**
     * Unique system-generated identifier for the user.
     */
    userId: string;
}
interface TokenIdInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId: string;
    tokenAddress?: never;
    blockchain?: never;
}
interface TokenAddressAndBlockchainInput {
    tokenId?: never;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress: string;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: TokenBlockchain;
}
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type UserIdOrTokenInput = UserIdInput | UserTokenInput;
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type TokenInfo = TokenIdInput | TokenAddressAndBlockchainInput;
/**
 * Represents a user token that is cached along with its expiration time.
 */
type CachedUserToken = UserTokenResponseData & {
    /**
     * The expiration time in seconds for the cached user token.
     */
    expirationTime: number;
};
type APIParams = APIParams$1<UserControlledWalletsClient, Record<string, CachedUserToken>>;
type ClientParams = ClientParams$1<Record<string, CachedUserToken>>;
/**
 * Represents the input for creating a challenge for PIN setup and create wallet(s).
 */
type CreateUserPinWithWalletsInput = {
    /**
     * Blockchain(s) the requested wallets will be created on.
     */
    blockchains: Blockchain[];
    /**
     * List of metadata fields to associate with the corresponding wallet.
     */
    metadata?: MetadataField[];
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignMessageInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * Indicator of whether the input message is encoded by hex. If TRUE, then the message should be a hex string. By default, it is False.
     */
    encodedByHex?: boolean;
    /**
     * The user friendly message that needs to be signed.
     * If it is a hex string, encodedByHex needs to be TRUE. The hex string should start with “0x” and have even length.
     */
    message: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;
/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignTransactionInput = {
    /**
     * Unique system generated identifier of the source wallet.
     */
    walletId: string;
    /**
     * The transaction object that needs to be signed. The structure of the json object will depend on the blockchain. [Evm transaction object](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_signtransaction).
     */
    transaction: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;
/**
 * Represents the input to sign the EIP-712 typed structured data from a specified user-controlled wallet.
 */
type SignTypedDataInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * A string represents the typed structured data in EIP-712.
     */
    data: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;
/**
 * Represents the input parameters for retrieving a token.
 */
interface GetTokenInput {
    /**
     * The ID of the token to retrieve.
     */
    id: string;
}
/**
 * Represents the input for accelerating a transaction.
 */
type AccelerateTransactionInput = {
    /**
     * The ID of the transaction that should be accelerated.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input for cancelling a transaction.
 */
type CancelTransactionInput = {
    /**
     * The ID of the transaction that should be cancelled.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Defines the parameters for creating a new transaction.
 */
type CreateTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amounts: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only erc1155 supports safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration to determine the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & UserIdOrTokenInput & TokenInfo & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a new contract execution transaction.
 */
type CreateContractExecutionTransactionInput = {
    /**
     * The contract ABI function signature or `callData` field is required for interacting with the smart contract. The ABI function signature cannot be used simultaneously with `callData`. e.g. Burn(uint256).
     */
    abiFunctionSignature?: string;
    /**
     * The contract ABI function signature parameters for executing the contract interaction. Supported parameter types include string, integer, boolean, and array. These parameters should be used exclusively with the abiFunctionSignature and cannot be used with `callData`.
     */
    abiParameters?: Array<any>;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the `0x` prefix, to be executed. It is important to note that the usage of `callData` is mutually exclusive with the `abiFunctionSignature` and `abiParameters`. Therefore, `callData` cannot be utilized simultaneously with either `abiFunctionSignature` or `abiParameters`.
     */
    callData?: string;
    /**
     * The amount of native token that will be sent to the contract abi execution. Optional field for payable api only, if not provided, no native token will be sent.
     */
    amount?: string;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Optional reference or description used to identify the transaction.
     */
    refId?: string;
    /**
     * Unique system generated identifier of the wallet. Required when source Address and blockchain is not provided. Mutually exclusive. For contract deploys this wallet ID will be used as the source.
     */
    walletId: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateContractExecutionFeeInput = {
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters: Array<any>;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Information about the source.
     */
    source: {
        /**
         * Identifier for the originating wallet.
         */
        walletId: string;
    } | {
        /**
         * Blockchain associated with the transaction. Required along with sourceAddress.
         */
        blockchain: EstimateContractExecutionTransactionFeeRequestBlockchain;
        /**
         * The source blockchain address of the transaction.
         */
        sourceAddress: string;
    };
} & UserIdOrTokenInput;
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateTransferFeeInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * The source blockchain address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId?: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
} & UserIdOrTokenInput & TokenInfo;
/**
 * Represents the input for retrieving a transaction.
 */
type GetTransactionInput = {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: GetTransactionTxTypeEnum;
} & UserIdOrTokenInput;
/**
 * Defines the parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines whether the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: ListTransactionsOperationEnum;
    /**
     * Filters transactions based on their current state.
     */
    state?: ListTransactionsStateEnum;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: ListTransactionsTxTypeEnum;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
} & UserIdOrTokenInput & Pagination;
/**
 * Represents the input parameters for validating an address.
 */
interface ValidateAddressInput {
    /**
     * The blockchain address to be validated.
     */
    address: string;
    /**
     * The blockchain that the address should belong to.
     */
    blockchain: Blockchain;
}
/**
 * Represents the input parameters for creating a user.
 */
type CreateUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};
/**
 * Represents the input parameters for resending the OTP.
 */
type ResendOTPInput = {
    /**
     * The OTP is bound on a user and purpose, and uses this value to identify the request.
     */
    otpToken: string;
    /**
     * Sends OTP email to the destination address.
     */
    email: string;
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId?: string;
} & WithIdempotencyKey & UserIdOrTokenInput;
/**
 * Represents the input parameters for creating a device token for email login.
 */
type CreateDeviceTokenForEmailLoginInput = {
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId: string;
    /**
     * Sends OTP email to the destination address.
     */
    email: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for fetching a user.
 */
type GetUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};
/**
 * Represents the input parameters for fetching a user by user token.
 */
type GetUserByTokenInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};
/**
 * Represents the input parameters for fetching a challenge.
 */
type GetUserChallengeInput = {
    /**
     * The unique identifier for the challenge.
     */
    challengeId: string;
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};
/**
 * Represents the input parameters for listing users.
 */
type ListUsersInput = {
    /**
     * The pin status to filter users. (Optional).
     */
    pinStatus?: ListUsersPinStatusEnum;
    /**
     * The security question status to filter users. (Optional).
     */
    securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum;
} & Pagination;
/**
 * Represents the input parameters for fetching a user's challenges.
 */
type ListUserChallengesInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    /**
     * The status of challenges to query. (Optional).
     */
    challengeStatus?: ListUserChallengesStatusEnum;
};
/**
 * Represents the input parameters for refreshing a user token.
 */
type RefreshUserTokenInput = {
    /**
     * Use the refresh token passed from sdk/performLogin to get a new userToken. Each refreshToken has a corresponding userToken for verification purposes.
     */
    refreshToken: string;
} & WithIdempotencyKey & UserIdOrTokenInput;
/**
 * Represents the input parameters for fetching a user.
 */
type CreateDeviceTokenForSocialLoginInput = {
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a user token.
 */
type CreateUserTokenInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};
/**
 * Represents the input parameters for creating multiple wallets.
 */
type CreateWalletsInput = {
    /**
     * The blockchains for which to create wallets.
     */
    blockchains: Blockchain[];
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: MetadataField[];
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input parameters for retrieving a wallet.
 */
type GetWalletInput = {
    /**
     * The ID of the wallet to retrieve.
     */
    id: string;
} & UserIdOrTokenInput;
/**
 * Represents the input parameters for retrieving the NFT balance of a wallet.
 */
type GetWalletNFTBalanceInput = {
    /**
     * The ID of the wallet to retrieve the NFTs for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: 'ERC20' | 'ERC721' | 'ERC1155';
} & UserIdOrTokenInput & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input parameters for retrieving the token balance of a wallet.
 */
type GetWalletTokenBalanceInput = {
    /**
     * The ID of the wallet to retrieve the tokens for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: 'ERC20' | 'ERC721' | 'ERC1155';
} & UserIdOrTokenInput & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input for listing wallets.
 */
type ListWalletsFilterInput = {
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain?: Blockchain;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
} & UserIdOrTokenInput & Pagination;
/**
 * Represents the input parameters for updating a wallet.
 */
type UpdateWalletInput = {
    /**
     * The ID of the wallet to be updated.
     */
    id: string;
    /**
     * The new name for the wallet.
     */
    name?: string;
    /**
     * The new refId for the wallet.
     */
    refId?: string;
} & UserIdOrTokenInput;

/**
 * Represents input parameters for managing a user's PIN.
 */
type ManageUserPinInput = UserIdOrTokenInput & WithIdempotencyKey;

declare const defaultBaseUrl = "https://api.circle.com";

type CircleUserControlledWalletsClient = ReturnType<typeof initiateUserControlledWalletsClient>;
/**
 * Initiates a client for Circle's User Controlled Wallets.
 * @param params - The client parameters.
 * @returns - The client object with various methods.
 */
declare function initiateUserControlledWalletsClient({ apiKey, baseUrl, storage, userAgent, headers, }: ClientParams): {
    /**
     * Fetches details of a specific token given its unique identifier.
     * Every token in your network of wallets has a UUID associated with it,
     * regardless of whether it's already recognized or was added as a monitored token.
     * @example
     * ```
     * const response = await client.getToken(id);
     * console.log(response.data.token)
     * ```
     */
    getToken: ({ id }: GetTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.TokenResponse>>;
    /**
     * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signMessage({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  encodedByHex: false,
     *  message: 'I agree with this transfer',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signMessage: ({ userToken, userId, ...input }: SignMessageInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Signature>>;
    /**
     * Generates a challenge for signing a user transaction.
     * @example
     * ```
     * const response = await client.signTransaction({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  transaction: 'I agree with this transfer',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    signTransaction: ({ userToken, userId, transaction, ...input }: SignTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.SignTransactionResponse>>;
    /**
     * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signTypedData({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  data: '{ \"types\": { \"Data\": [{ \"name\": \"dummy\", \"type\": \"string\" }],}, \"domain\": { \"name\": \"Test\", \"chainId\": 1337 }, \"primaryType\": \"Data\", \"message\": { \"dummy\": \"dummy\" }}',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signTypedData: ({ userToken, userId, ...input }: SignTypedDataInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Signature>>;
    /**
     * Request testnet tokens for your wallet.
     * @example
     * ```
     * const response = await client.requestTestnetTokens({
     *  address: '0xb395f4ea0ba29494ce839613fffba74279579269',
     *  blockchain: TestnetBlockchain.EthSepolia,
     *  usdc: true,
     * });
     * console.log(response.status)
     * ```
     */
    requestTestnetTokens: (input: _shared_core.RequestTestnetTokensInput) => Promise<axios.AxiosResponse<void, any>>;
    /**
     * Add a new token to the monitored token list.
     * @example
     * ```
     * const response = await client.createMonitoredTokens({
     *  tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * });
     * console.log(response)
     * ```
     */
    createMonitoredTokens: (input: _shared_core.CreateMonitoredTokensInput) => Promise<void>;
    /**
     * Edit the monitored token list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokens({
     *  tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * });
     * console.log(response)
     * ```
     */
    updateMonitoredTokens: (input: _shared_core.UpdateMonitoredTokensInput) => Promise<void>;
    /**
     * Get monitored tokens.
     * @example
     * ```
     * const response = await client.listMonitoredTokens();
     * console.log(response)
     * ```
     */
    listMonitoredTokens: (input?: _shared_core.ListMonitoredTokensInput | undefined) => Promise<void>;
    /**
     * Delete tokens from the monitored token list.
     * @example
     * ```
     * const response = await client.deleteMonitoredTokens({
     *  tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * });
     * console.log(response)
     * ```
     */
    deleteMonitoredTokens: (input: _shared_core.DeleteMonitoredTokensInput) => Promise<axios.AxiosResponse<void, any>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokensScope({
     *  scope: 'MONITOR_ALL',
     * });
     * console.log(response)
     * ```
     */
    updateMonitoredTokensScope: (input: _shared_core.UpdateMonitoredTokensScopeInput) => Promise<void>;
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @example
     * ```
     * const response = await client.createSubscription({
     *  endpoint: 'https://example.org/handler/for/notifications',
     * });
     * console.log(response)
     * ```
     */
    createSubscription: (input: _shared_core.CreateSubscriptionInput) => Promise<void>;
    /**
     * Delete a notification subscription.
     * ```
     * const response = await client.deleteSubscription('b3d9d2d5-4c12-4946-a09d-953e82fae2b0');
     * console.log(response)
     * ```
     */
    deleteSubscription: (subscriptionId: string) => Promise<void>;
    /**
     * Retrieve an existing notification subscription.
     * ```
     * const response = await client.getSubscription('b3d9d2d5-4c12-4946-a09d-953e82fae2b0');
     * console.log(response)
     * ```
     */
    getSubscription: (subscriptionId: string) => Promise<void>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.
     * In the headers of each webhook, you can find
     * 1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.
     * 2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * ```
     * const response = await client.getNotificationSignature('b3d9d2d5-4c12-4946-a09d-953e82fae2b0');
     * console.log(response)
     * ```
     */
    getNotificationSignature: (subscriptionId: string) => Promise<void>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * ```
     * const response = await client.listSubscriptions();
     * console.log(response)
     * ```
     */
    listSubscriptions: () => Promise<void>;
    /**
     * Update subscription endpoint to receive notifications.
     * ```
     * const response = await client.updateSubscription({
     *  id: 'b3d9d2d5-4c12-4946-a09d-953e82fae2b0',
     *  name: 'payment-processor',
     *  enabled: true,
     * });
     * console.log(response)
     * ```
     */
    updateSubscription: ({ id, ...input }: _shared_core.UpdateSubscriptionInput) => Promise<void>;
    /**
     * Get a deviceToken to login with email OTP in SDK.
     * @example
     * ```
     * const response = await userClient.createDeviceTokenForEmailLogin({
     *  deviceId: 'f05bb738-efbe-4774-9557-d46985b54c9c',
     *  email: 'deepakreddy.gummi@circle.com'
     * })
     * console.log(response.data)
     * ```
     */
    createDeviceTokenForEmailLogin: ({ deviceId, idempotencyKey, email, }: CreateDeviceTokenForEmailLoginInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.DeviceTokenEmail>>;
    /**
     * Get deviceToken to perform social login in SDK.
     * @example
     * ```
     * const response = await userClient.createDeviceTokenForSocialLogin({
     *  deviceId: 'f05bb738-efbe-4774-9557-d46985b54c9c',
     * })
     * console.log(response.data)
     * ```
     */
    createDeviceTokenForSocialLogin: ({ deviceId, idempotencyKey, }: CreateDeviceTokenForSocialLoginInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.DeviceTokenSocial>>;
    /**
     * Get a new userToken with the refreshToken passed over from sdk/performLogin which matches to the current userToken.
     * @example
     * ```
     * const response = await userClient.refreshUserToken({
     *  userToken: 'dummy-user-token',
     *  refreshToken: 'dummy-refresh-token',
     * })
     * console.log(response.data)
     * ```
     */
    refreshUserToken: ({ userId, userToken, idempotencyKey, refreshToken, }: RefreshUserTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.RefreshUserToken>>;
    /**
     * When the users don’t receive the OTP email,  you can call this API to resend OTP email. The prior OTP email would expire after the new one is sent out.
     * @example
     * ```
     * const response = await userClient.resendOTP({
     *  userToken: 'dummy-user-token',
     *  email: 'dummy.email@circle.com',
     *  otpToken: 'dummy-otp-token',
     * })
     * console.log(response.data)
     * ```
     */
    resendOTP: ({ userToken, idempotencyKey, deviceId, userId, ...input }: ResendOTPInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ResentOTP>>;
    /**
     * Generates a challenge for accelerating a specified on-chain digital asset transfer from a user-controlled wallet.
     *
     * Additional gas fees may be incurred.
     * @example
     * ```
     * const response = await client.accelerateTransaction({
     *  userToken: 'dummy-user-token',
     *  id: '50dcf3c7-bcc0-465d-bb72-7b84f82a4887',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    accelerateTransaction: ({ userToken, userId, id, idempotencyKey, }: AccelerateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.AccelerateTransactionForEndUserResponse>>;
    /**
     * Generates a challenge for initiating an on-chain digital asset transfer from a specified user-controlled wallet.
     * @example
     * ```
     * const response = await client.createTransaction({
     *  userToken: 'dummy-user-token',
     *  amount: ['0.01'],
     *  destinationAddress: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *  tokenId: '738c8a6d-8896-46d1-b2cb-083600c1c69b',
     *  walletId: 'a635d679-4207-4e37-b12e-766afb9b3892',
     *  fee: {
     *    type: 'level',
     *    config: {
     *      feeLevel: 'HIGH',
     *    },
     *  },
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createTransaction: ({ userToken, userId, idempotencyKey, fee, ...input }: CreateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateTransferTransactionForEndUserResponse>>;
    /**
     * Generates a challenge for cancelling a specified on-chain digital asset transfer from a user-controlled wallet.
     *
     * Gas fees may still be incurred.
     * @example
     * ```
     * const response = await client.cancelTransaction({
     *  userToken: 'dummy-user-token',
     *  id: '50dcf3c7-bcc0-465d-bb72-7b84f82a4887',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    cancelTransaction: ({ userToken, userId, id, idempotencyKey, }: CancelTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CancelTransactionForEndUserResponse>>;
    /**
     * Retrieves info for a single transaction using it's unique identifier.
     * @example
     * ```
     * const response = await client.getTransaction({
     *  userToken: 'dummy-user-token',
     *  id: '50dcf3c7-bcc0-465d-bb72-7b84f82a4887',
     * })
     * console.log(response.data)
     * ```
     */
    getTransaction: ({ id, userToken, userId, txType }: GetTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.TransactionResponse>>;
    /**
     * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
     * @example
     * ```
     * const response = await client.listTransactions({
     *  userToken: 'dummy-user-token',
     * });
     * console.log(response.data)
     * ```
     */
    listTransactions: ({ userToken, blockchain, destinationAddress, includeAll, operation, state, txHash, txType, userId, walletIds, from, pageAfter, pageBefore, pageSize, to, }: ListTransactionsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Transactions>>;
    /**
     * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
     * @example
     * ```
     * const response = await client.estimateContractExecutionFee({
     *  abiFunctionSignature: 'burn(uin256)',
     *  abiParameters: [1000],
     *  contractAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *  source: {
     *    walletId: '9a014a34-4706-4e3f-879d-fc2a8764877c',
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    estimateContractExecutionFee: ({ userId, userToken, source, ...input }: EstimateContractExecutionFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Generates a challenge for creating a transaction which executes a smart contract. ABI parameters must be passed in the request.
     * @example
     * ```
     * const response = await client.createUserTransactionContractExecutionChallenge({
     *  userToken: 'dummy-user-token',
     *  amount: '0.01',
     *  abiFunctionSignature: 'burn(uint256)',
     *  abiParameters: [
     *    1,
     *  ],
     *  contractAddress: '0xf9f4d0a9dcc57d15d32a9a52c71fdfef91bdf0e4',
     *  refId: 'f26d2545-7ff7-4cac-ba02-40e1975e5dbe',
     *  walletId: 'd67e2f61-2b4f-40ab-9ac5-eee8ff56613c',
     *  fee: {
     *    type: 'level',
     *    config: {
     *      feeLevel: 'HIGH',
     *    },
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    createUserTransactionContractExecutionChallenge: ({ userToken, userId, idempotencyKey, fee, ...input }: CreateContractExecutionTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateContractExecutionTransactionForEndUserResponse>>;
    /**
     * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
     * @example
     * ```
     * const response = await client.estimateTransferFee({
     *  amount: ['0.01'],
     *  destinationAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *  tokenId: '9606f293-5b81-4970-acd3-c35c157461c2',
     * })
     * console.log(response.data)
     * ```
     */
    estimateTransferFee: ({ userToken, userId, amount, ...input }: EstimateTransferFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Confirms that a specified address is valid for a certain blockchain.
     * @example
     * ```
     * const response = await client.validateAddress({
     *  address: '0xa95f8fafb3f6ae0f9ba7204eef07bde7a64cf2bc',
     *  blockchain: 'ETH-SEPOLIA',
     * })
     * console.log(response.data?.isValid)
     * ```
     */
    validateAddress: (input: ValidateAddressInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ValidateAddress>>;
    /**
     * Generates a challenge for creating a new user-controlled wallet or batch of wallets, specifying blockchain and wallet name.
     * @example
     * ```
     * const response = await userClient.createWallet({
     *  userToken: 'dummy-user-token',
     *  blockchains: [Blockchain.Eth, Blockchain.Matic],
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createWallet: ({ userToken, userId, idempotencyKey, accountType, ...input }: CreateWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateEndUserWallet>>;
    /**
     * Retrieves a list of all user-controlled wallets that fit the specified parameters.
     * @example
     * ```
     * const response = await userClient.listWallets({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallets)
     * ```
     */
    listWallets: ({ userId, userToken, address, blockchain, from, pageAfter, pageBefore, pageSize, to, walletSetId, refId, }: ListWalletsFilterInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Wallets>>;
    /**
     * Retrieves info for a single user-controlled wallet using it's unique identifier.
     * @example
     * ```
     * const response = await userClient.getWallet({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallet)
     * ```
     */
    getWallet: ({ id, userToken, userId }: GetWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.WalletResponse>>;
    /**
     * Updates info for a single user-controlled wallet using it's unique identifier.
     * @example
     * ```
     * const response = await userClient.updateWallet({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallet)
     * ```
     */
    updateWallet: ({ id, name, refId, userToken, userId }: UpdateWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.WalletResponse>>;
    /**
     * Fetches the digital asset balance for a single user-controlled wallet using its unique identifier.
     * @example
     * ```
     * const response = await userClient.getWalletTokenBalance({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.tokenBalances)
     * ```
     */
    getWalletTokenBalance: ({ walletId, userToken, userId, includeAll, name, pageAfter, pageBefore, pageSize, tokenAddresses, standard, }: GetWalletTokenBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Balances>>;
    /**
     * Fetches the info for all NFTs stored in a single user-controlled wallet, using the wallets unique identifier.
     * @example
     * ```
     * const response = await userClient.getWalletNFTBalance({
     *  id: 'dummy-wallet-id',
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.nfts)
     * ```
     */
    getWalletNFTBalance: ({ walletId, userToken, userId, includeAll, name, pageAfter, pageBefore, pageSize, tokenAddresses, standard, }: GetWalletNFTBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Nfts>>;
    /**
     * Create a user.
     * @example
     * ```
     * const response = client.createUser({
     *   userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.status)
     * ```
     */
    createUser: ({ ...input }: CreateUserInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.User>>;
    /**
     * Get user by ID.
     * @example
     * ```
     * const response = client.getUser({
     *   userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.data?.user?.pinStatus)
     * ```
     */
    getUser: ({ userId }: GetUserInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.User>>;
    /**
     * Get user's PIN and Security Question statuses.
     * @example
     * ```
     * const response = await userClient.getUserStatus({
     *   userToken: 'dummy-user-token',
     * })
     *  console.log(response.data?.pinDetails)
     * ```
     */
    getUserStatus: ({ userToken }: GetUserByTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.User>>;
    /**
     * Get all the users under the entity, sorted by the create date DESC order.
     * @example
     * ```
     * const response = await userClient.listUsers()
     * console.log(response.data?.users?.at(0)?.pinStatus)
     * ```
     */
    listUsers: ({ pinStatus, securityQuestionStatus, from, to, pageBefore, pageAfter, pageSize, }?: ListUsersInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Users>>;
    /**
     * Generate user session and SDK secret key.
     * @example
     * ```
     * const response = await userClient.createUserToken({
     *  userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.data?.userToken, response.data?.encryptionKey)
     * ```
     */
    createUserToken: ({ ...input }: CreateUserTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UserTokenResponse>>;
    /**
     * Get the status of a challenge.
     * @example
     * ```
     * const response = await userClient.getUserChallenge({
     *  userToken: 'dummy-user-token',
     *  challengeId: '0db6141b-1091-4e39-a20b-6a4cde68e1e7',
     * })
     * console.log(response.data?.challenge?.status)
     * ```
     */
    getUserChallenge: ({ userToken, challengeId }: GetUserChallengeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ChallengeResponse>>;
    /**
     * List all challenges by status for a user.
     * @example
     * ```
     * const response = await userClient.listUserChallenges({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challenges?.at(0)?.status)
     * ```
     */
    listUserChallenges: ({ userToken, challengeStatus }: ListUserChallengesInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Challenges>>;
    /**
     * Create a challenge for PIN setup without setting up wallets.
     * @example
     * ```
     * const response = await userClient.createUserPin({
     *  userId: '67eb6eac-a7f5-4c04-9200-2fbf969426b0',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Create a challenge for PIN setup and create wallet(s).
     * @example
     * ```
     * const response = await userClient.createUserPinWithWallets({
     *  userToken: 'dummy-user-token',
     *  blockchains: [Blockchain.Eth, Blockchain.Matic],
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    createUserPinWithWallets: ({ userToken, userId, idempotencyKey, accountType, ...input }: CreateUserPinWithWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Create a challenge to update a user's PIN via existing PIN.
     * @example
     * ```
     * const response = await userClient.updateUserPin({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    updateUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Create a challenge to change a user's PIN via Security Questions.
     * @example
     * ```
     * const response = await userClient.restoreUserPin({
     *  userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     */
    restoreUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
};

export { type APIParams, type AccelerateTransactionInput, type CancelTransactionInput, type CircleUserControlledWalletsClient, type ClientParams, type CreateContractExecutionTransactionInput, type CreateDeviceTokenForEmailLoginInput, type CreateDeviceTokenForSocialLoginInput, type CreateTransactionInput, type CreateUserInput, type CreateUserPinWithWalletsInput, type CreateUserTokenInput, type CreateWalletsInput, type EstimateContractExecutionFeeInput, type EstimateTransferFeeInput, type GetTokenInput, type GetTransactionInput, type GetUserByTokenInput, type GetUserChallengeInput, type GetUserInput, type GetWalletInput, type GetWalletNFTBalanceInput, type GetWalletTokenBalanceInput, type ListTransactionsInput, type ListUserChallengesInput, type ListUsersInput, type ListWalletsFilterInput, type RefreshUserTokenInput, type ResendOTPInput, type SignMessageInput, type SignTransactionInput, type SignTypedDataInput, type TokenAddressAndBlockchainInput, type TokenIdInput, type TokenInfo, type UpdateWalletInput, type UserIdInput, type UserIdOrTokenInput, type UserTokenInput, type ValidateAddressInput, defaultBaseUrl, initiateUserControlledWalletsClient };
