import * as axios from 'axios';
import * as _shared_clients_configurations from './clients/configurations';
import * as _shared_core from './clients/core';
import { APIParams as APIParams$1, ClientParams as ClientParams$1, WithIdempotencyKey, FeeConfiguration, Pagination } from './clients/core';
import * as _shared_clients_developer_controlled_wallets from './clients/developer-controlled-wallets';
import { TokenBlockchain, DeveloperControlledWalletsClient, FeeLevel, EstimateContractExecutionTransactionFeeRequestBlockchain, TransactionType, Blockchain, Operation, ListTransactionsStateEnum, WalletMetadata, AccountType } from './clients/developer-controlled-wallets';
export { AccountType, Balance, Blockchain, CustodyType, EstimateContractExecutionTransactionFeeRequestBlockchain, FeeLevel, GetTransactionTxTypeEnum, ListTransactionsOperationEnum, ListTransactionsStateEnum, ListTransactionsTxTypeEnum, ListWalletBalanceStandardEnum, ListWalletNftsStandardEnum, Operation, TokenBlockchain, TokenStandard, TransactionState, TransactionType, WalletState } from './clients/developer-controlled-wallets';

interface TokenIdInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId: string;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress?: never;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: never;
}
interface TokenAddressAndBlockchainInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId?: never;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress: string;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: TokenBlockchain;
}
/**
 * Type of the data that is stored.
 */
type StoredData = {
    /**
     * The publicKey that is associated to the entity.
     */
    publicKey: string;
};
interface Config {
    /**
     * Your configured entity secret.
     */
    entitySecret: string;
}
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type TokenInfo = TokenIdInput | TokenAddressAndBlockchainInput;
type APIParams = APIParams$1<DeveloperControlledWalletsClient, StoredData> & Config;
type ClientParams = ClientParams$1<StoredData> & Config;
/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignTransactionInput = {
    /**
     * System-generated unique identifier of the resource.
     */
    walletId: string;
    /**
     * Raw transaction string that needs to be signed. Must be base64 encoded.
     */
    rawTransaction: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
};
/**
 * Represents the input to sign the EIP-191 message from a specified developer-controlled wallet.
 */
type SignMessageInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * Indicator of whether the input message is encoded by hex. If TRUE, then the message should be a hex string. By default, it is False.
     */
    encodedByHex?: boolean;
    /**
     * The user friendly message that needs to be signed.
     * If it is a hex string, encodedByHex needs to be TRUE. The hex string should start with “0x” and have even length.
     */
    message: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
};
/**
 * Represents the input to sign the EIP-712 typed structured data from a specified developer-controlled wallet.
 */
type SignTypedDataInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * A string represents the typed structured data in EIP-712.
     */
    data: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
};
/**
 * Represents the input parameters for retrieving a token.
 */
interface GetTokenInput {
    /**
     * The ID of the token to retrieve.
     */
    id: string;
}
/**
 * Represents the input parameters for accelerating a transaction.
 */
type AccelerateTransactionInput = {
    /**
     * The ID of the transaction to be accelerated.
     */
    id: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for cancelling a transaction.
 */
type CancelTransactionInput = {
    /**
     * The ID of the transaction to be cancelled.
     */
    id: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a new transaction.
 */
type CreateTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amounts: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & TokenInfo & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a new contract execution transaction.
 */
type CreateContractExecutionTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount?: string;
    /**
     * The contract ABI function signature to be interacted with in the smart contract.
     * Example: `burn(uint256)`.
     */
    abiFunctionSignature?: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     * Supported types include string, number, and boolean.
     */
    abiParameters?: Array<any>;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & WithIdempotencyKey;
/**
 * Defines the parameters for creating a new transfer transaction.
 */
type CreateTransferTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only erc1155 supports safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration to determine the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & WithIdempotencyKey & TokenInfo;
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateContractExecutionFeeInput = {
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters: Array<any>;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Information about the source.
     */
    source: {
        /**
         * Identifier for the originating wallet.
         */
        walletId: string;
    } | {
        /**
         * Blockchain associated with the transaction. Required along with sourceAddress.
         */
        blockchain: EstimateContractExecutionTransactionFeeRequestBlockchain;
        /**
         * The source blockchain address of the transaction.
         */
        sourceAddress: string;
    };
};
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateTransferFeeInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * The source blockchain address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId?: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
} & TokenInfo;
/**
 * Represents the input for retrieving a transaction.
 */
interface GetTransactionInput {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: TransactionType;
}
/**
 * Defines the parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines if the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: Operation;
    /**
     * Filters transactions based on their current state.
     */
    state?: ListTransactionsStateEnum;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: TransactionType;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
} & Pagination;
/**
 * Represents the input parameters for validating an address.
 */
interface ValidateAddressInput {
    /**
     * The blockchain address to be validated.
     */
    address: string;
    /**
     * The blockchain that the address should belong to.
     */
    blockchain: Blockchain;
}
/**
 * Represents the input for creating multiple wallets.
 */
type CreateWalletsInput = {
    /**
     * The blockchains for which to create wallets.
     */
    blockchains: Blockchain[];
    /**
     * The number of wallets to create for each selected blockchain.
     * This count will be multiplied by the number of selected blockchains.
     * For example, with count=2 and blockchains.length=2, it will create a total of 4 new wallets.
     */
    count: number;
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: WalletMetadata[];
    /**
     * The ID of the wallet set for which to create the wallets.
     */
    walletSetId: string;
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & WithIdempotencyKey;
/**
 * Represents the input for retrieving a wallet.
 */
interface GetWalletInput {
    /**
     * The ID of the wallet to retrieve.
     */
    id: string;
}
/**
 * Represents the input for retrieving the nft balance of a wallet.
 */
type GetWalletNFTBalanceInput = {
    /**
     * The ID of the wallet to retrieve the nfts for.
     */
    id: string;
    /**
     * Specifies whether to include all token.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: 'ERC20' | 'ERC721' | 'ERC1155';
} & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input for retrieving the token balance of a wallet.
 */
type GetWalletTokenBalanceInput = {
    /**
     * The ID of the wallet to retrieve the tokens for.
     */
    id: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: 'ERC20' | 'ERC721' | 'ERC1155';
} & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input for listing wallets.
 */
type ListWalletsInput = {
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain?: Blockchain;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
} & Pagination;
/**
 * Represents the input for updating a wallet.
 */
interface UpdateWalletInput {
    /**
     * The ID of the wallet to be updated.
     */
    id: string;
    /**
     * The new name for the wallet.
     */
    name?: string;
    /**
     * The new refId for the wallet.
     */
    refId?: string;
}
/**
 * Represents the input for creating a wallet set.
 */
type CreateWalletSetInput = {
    /**
     * The name you want to apply to your wallet set.
     */
    name: string;
} & WithIdempotencyKey;
/**
 * Represents the input for retrieving a wallet set.
 */
interface GetWalletSetInput {
    /**
     * The ID of the wallet set to retrieve.
     */
    id: string;
}
/**
 * Represents the input for listing wallet sets.
 */
type ListWalletSetsInput = {
    xRequestId?: string;
} & Pagination;
/**
 * Represents the input for updating a wallet set.
 */
interface UpdateWalletSetInput {
    /**
     * The ID of the wallet set to be updated.
     */
    id: string;
    /**
     * The new name for the wallet set.
     */
    name: string;
}

declare const defaultBaseUrl = "https://api.circle.com";

type CircleDeveloperControlledWalletsClient = ReturnType<typeof initiateDeveloperControlledWalletsClient>;
/**
 * Initiates a client for Circle's Developer Controlled Wallets.
 * @param params - The client parameters.
 * @returns - The client object with various methods.
 */
declare function initiateDeveloperControlledWalletsClient({ apiKey, baseUrl, entitySecret, storage, userAgent, headers, }: ClientParams): {
    /**
     * Sign the EIP-191 message from a specified developer-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signMessage({
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  encodedByHex: false,
     *  message: 'I agree with this transfer',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signMessage: (input: SignMessageInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignatureResponse>>;
    /**
     * Sign the EIP-712 typed structured data from a specified developer-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signTypedData({
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  data: '{ "types": { "Data": [{ "name": "dummy", "type": "string" }],}, "domain": { "name": "Test", "chainId": 1337 }, "primaryType": "Data", "message": { "dummy": "dummy" }}',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signTypedData: (input: SignTypedDataInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignatureResponse>>;
    /**
     * Sign a transaction from a specific developer-controlled wallet.
     * @example
     * ```
     * const response = await client.signTransaction({
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  rawTransaction: 'ZGVlcGFrcm...VkZHlndW1taQ==',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signTransaction: (input: SignTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignTransactionResponse>>;
    /**
     * Generate a developer controlled wallet set.
     * @example
     * ```
     * const response = await client.createWalletSet({ name: 'My first wallet set' })
     * console.log(response.data?.walletSet)
     * ```
     */
    createWalletSet: ({ idempotencyKey, name }: CreateWalletSetInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSetResponse>>;
    /**
     * Retrieve info for a single wallet set.
     * @example
     * ```
     * const response = await client.getWalletSet({ id: 'd1daae42-6853-4d66-8184-65468e95225b' })
     * console.log(response.data?.walletSet)
     * ```
     */
    getWalletSet: ({ id }: GetWalletSetInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSetResponse>>;
    /**
     * Retrieve a list of all wallet sets.
     * @example
     * ```
     * const response = await client.listWalletSets({})
     * console.log(response.data?.walletSets)
     * ```
     */
    listWalletSets: ({ xRequestId, from, pageAfter, pageBefore, pageSize, to, }?: ListWalletSetsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSets>>;
    /**
     * Update the wallet set associated with the given wallet set ID.
     * @example
     * ```
     * const response = await client.updateWalletSet({
     *  id: 'b26bb9f9-7b85-48e2-a613-1923fb470e2e',
     *  name: 'My new walletSet name'
     * })
     * console.log(response.data?.walletSet)
     * ```
     */
    updateWalletSet: ({ id, name }: UpdateWalletSetInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSetResponse>>;
    /**
     * Create one or multiple wallets within a wallet set, specifying the blockchain, count and optional metadata.
     * @example
     * ```
     * const response = client.createWallets({
     *   blockchains: ["AVAX-FUJI"],
     *   count: 1,
     *   walletSetId: "67eb6eac-a7f5-4c04-9200-2fbf969426b0",
     * })
     * console.log(response.data?.wallets)
     * ```
     */
    createWallets: ({ idempotencyKey, accountType, ...input }: CreateWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Wallets>>;
    /**
     * List wallets based on the specified parameters.
     * @example
     * ```
     * const response = client.listWallets({})
     * console.log(response.data?.wallets)
     * ```
     */
    listWallets: ({ address, blockchain, refId, from, pageAfter, pageBefore, pageSize, to, walletSetId, }?: ListWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Wallets>>;
    /**
     * Retrieve information for a specific wallet using its unique identifier.
     * @example
     * ```
     * const response = client.getWallet({ id: '223d9a78-ca33-4cbd-ab83-8f083e3c045b' })
     * console.log(response.data?.wallet)
     * ```
     */
    getWallet: ({ id }: GetWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletResponse>>;
    /**
     * Update information for a specific wallet using its unique identifier.
     * @example
     * ```
     * const response = client.updateWallet({ id: '1f29cce1-ab6c-41ad-84d8-9d223d014881', name: 'Updated name' })
     * console.log(response.data?.wallet)
     * ```
     */
    updateWallet: ({ id, name, refId }: UpdateWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletResponse>>;
    /**
     * Fetch the balance of digital assets for a specific wallet using its unique identifier.
     * @example
     * ```
     * const response = client.getWalletTokenBalance({ id: 'e518abf8-882d-4fa1-931e-596b28aa970b' })
     * console.log(response.data?.tokenBalances)
     * ```
     */
    getWalletTokenBalance: ({ id, includeAll, name, pageAfter, pageBefore, pageSize, tokenAddresses, standard, }: GetWalletTokenBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Balances>>;
    /**
     * Fetch the balance of digital assets for a specific wallet using its unique identifier.
     * @example
     * ```
     * const response = client.getWalletNFTBalance({ id: 'b21c473f-8c93-4826-90f5-cad3cfeef4c1' })
     * console.log(response.data?.nfts)
     * ```
     */
    getWalletNFTBalance: ({ id, includeAll, name, pageAfter, pageBefore, pageSize, tokenAddresses, standard, }: GetWalletNFTBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Nfts>>;
    /**
     * Accelerates a specific on-chain digital asset transfer from a developer-controlled wallet.
     *
     * Can incur additional gas fees.
     * @example
     * ```
     * const response = await client.accelerateTransaction({ id });
     * console.log(response.data?.id)
     * ```
     */
    accelerateTransaction: ({ id, idempotencyKey }: AccelerateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.AccelerateTransactionForDeveloper>>;
    /**
     * Cancels a specific on-chain digital asset transfer from a developer-controlled wallet.
     *
     * Gas fees may still be incurred.
     * @example
     * ```
     * const response = await client.cancelTransaction({ id });
     * console.log(response.data)
     * ```
     */
    cancelTransaction: ({ id, idempotencyKey }: CancelTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.CancelTransactionForDeveloper>>;
    /**
     * Creates a transaction executing a smart contract. Request must include ABI parameters.
     * @example
     * ```
     * const response = await client.createContractExecutionTransaction({
     *  amount: '0.01',
     *  abiFunctionSignature: 'burn(uint256)',
     *  contractAddress: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *  walletId: 'a635d679-4207-4e37-b12e-766afb9b3892',
     *  fee: {
     *    type: 'level',
     *    config: {
     *      feeLevel: 'HIGH',
     *    },
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    createContractExecutionTransaction: ({ idempotencyKey, fee, ...input }: CreateContractExecutionTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateContractExecutionTransactionForDeveloper>>;
    /**
     * Initiates an on-chain digital asset transfer from a specified developer-controlled wallet.
     * @example
     * ```
     * const response = await client.createTransaction({
     *  amounts: ['0.01'],
     *  destinationAddress: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *  tokenId: '738c8a6d-8896-46d1-b2cb-083600c1c69b',
     *  walletId: 'a635d679-4207-4e37-b12e-766afb9b3892',
     *  fee: {
     *    type: 'level',
     *    config: {
     *      feeLevel: 'HIGH',
     *    },
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    createTransaction: ({ idempotencyKey, fee, amount, ...input }: CreateTransferTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateTransferTransactionForDeveloperResponse>>;
    /**
     * Retrieves information for a single transaction using its unique identifier.
     * @example
     * ```
     * const response = await client.getTransaction({
     *  id: '9fcb2e86-dec2-4226-81d1-4dbad429278c',
     * })
     * console.log(response.data?.transaction)
     * ```
     */
    getTransaction: ({ id, txType }: GetTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.TransactionResponse>>;
    /**
     * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
     * @example
     * ```
     * const response = await client.listTransactions({})
     * console.log(response.data?.transactions)
     * ```
     */
    listTransactions: ({ blockchain, destinationAddress, includeAll, operation, state, txHash, txType, walletIds, from, pageAfter, pageBefore, pageSize, to, }?: ListTransactionsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Transactions>>;
    /**
     * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
     * @example
     * ```
     * const response = await client.estimateContractExecutionFee({
     *  abiFunctionSignature: 'burn(uin256)',
     *  abiParameters: [1000],
     *  contractAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *  source: {
     *    walletId: '9a014a34-4706-4e3f-879d-fc2a8764877c',
     *  },
     * })
     * console.log(response.data)
     * ```
     */
    estimateContractExecutionFee: ({ source, ...input }: EstimateContractExecutionFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
     * @example
     * ```
     * const response = await client.estimateTransferFee({
     *  amount: ['0.01'],
     *  destinationAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *  tokenId: '9606f293-5b81-4970-acd3-c35c157461c2',
     * })
     * console.log(response.data)
     * ```
     */
    estimateTransferFee: ({ amount, ...input }: EstimateTransferFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Confirms that a specified address is valid for a certain blockchain.
     * @example
     * ```
     * const response = await client.validateAddress({
     *  address: '0xa95f8fafb3f6ae0f9ba7204eef07bde7a64cf2bc',
     *  blockchain: 'ETH-SEPOLIA',
     * })
     * console.log(response.data?.isValid)
     * ```
     */
    validateAddress: (input: ValidateAddressInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.ValidateAddress>>;
    /**
     * Get the public key associated with your entity.
     * @example
     * ```
     * const response = await client.getPublicKey();
     * console.log(response.data.publicKey)
     * ```
     */
    getPublicKey: () => Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.PublicKey>>;
    /**
     * Fetches details of a specific token given its unique identifier.
     * Every token in your network of wallets has a UUID associated with it,
     * regardless of whether it's already recognized or was added as a monitored token.
     * @example
     * ```
     * const response = await client.getToken(id);
     * console.log(response.data.token)
     * ```
     */
    getToken: ({ id }: GetTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.TokenResponse>>;
    /**
     * Request testnet tokens for your wallet.
     * @example
     * ```
     * const response = await client.requestTestnetTokens({
     *  address: '0xb395f4ea0ba29494ce839613fffba74279579269',
     *  blockchain: TestnetBlockchain.EthSepolia,
     *  usdc: true,
     * });
     * console.log(response.status)
     * ```
     */
    requestTestnetTokens: (input: _shared_core.RequestTestnetTokensInput) => Promise<axios.AxiosResponse<void, any>>;
    /**
     * Add a new token to the monitored token list.
     * @example
     * ```
     * const response = await client.createMonitoredTokens({
     *  tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * });
     * console.log(response)
     * ```
     */
    createMonitoredTokens: (input: _shared_core.CreateMonitoredTokensInput) => Promise<void>;
    /**
     * Edit the monitored token list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokens({
     *  tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * });
     * console.log(response)
     * ```
     */
    updateMonitoredTokens: (input: _shared_core.UpdateMonitoredTokensInput) => Promise<void>;
    /**
     * Get monitored tokens.
     * @example
     * ```
     * const response = await client.listMonitoredTokens();
     * console.log(response)
     * ```
     */
    listMonitoredTokens: (input?: _shared_core.ListMonitoredTokensInput | undefined) => Promise<void>;
    /**
     * Delete tokens from the monitored token list.
     * @example
     * ```
     * const response = await client.deleteMonitoredTokens({
     *  tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * });
     * console.log(response)
     * ```
     */
    deleteMonitoredTokens: (input: _shared_core.DeleteMonitoredTokensInput) => Promise<axios.AxiosResponse<void, any>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokensScope({
     *  scope: 'MONITOR_ALL',
     * });
     * console.log(response)
     * ```
     */
    updateMonitoredTokensScope: (input: _shared_core.UpdateMonitoredTokensScopeInput) => Promise<void>;
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @example
     * ```
     * const response = await client.createSubscription({
     *  endpoint: 'https://example.org/handler/for/notifications',
     * });
     * console.log(response)
     * ```
     */
    createSubscription: (input: _shared_core.CreateSubscriptionInput) => Promise<void>;
    /**
     * Delete a notification subscription.
     * ```
     * const response = await client.deleteSubscription('b3d9d2d5-4c12-4946-a09d-953e82fae2b0');
     * console.log(response)
     * ```
     */
    deleteSubscription: (subscriptionId: string) => Promise<void>;
    /**
     * Retrieve an existing notification subscription.
     * ```
     * const response = await client.getSubscription('b3d9d2d5-4c12-4946-a09d-953e82fae2b0');
     * console.log(response)
     * ```
     */
    getSubscription: (subscriptionId: string) => Promise<void>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.
     * In the headers of each webhook, you can find
     * 1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.
     * 2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * ```
     * const response = await client.getNotificationSignature('b3d9d2d5-4c12-4946-a09d-953e82fae2b0');
     * console.log(response)
     * ```
     */
    getNotificationSignature: (subscriptionId: string) => Promise<void>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * ```
     * const response = await client.listSubscriptions();
     * console.log(response)
     * ```
     */
    listSubscriptions: () => Promise<void>;
    /**
     * Update subscription endpoint to receive notifications.
     * ```
     * const response = await client.updateSubscription({
     *  id: 'b3d9d2d5-4c12-4946-a09d-953e82fae2b0',
     *  name: 'payment-processor',
     *  enabled: true,
     * });
     * console.log(response)
     * ```
     */
    updateSubscription: ({ id, ...input }: _shared_core.UpdateSubscriptionInput) => Promise<void>;
};

export { type APIParams, type AccelerateTransactionInput, type CancelTransactionInput, type CircleDeveloperControlledWalletsClient, type ClientParams, type Config, type CreateContractExecutionTransactionInput, type CreateTransactionInput, type CreateTransferTransactionInput, type CreateWalletSetInput, type CreateWalletsInput, type EstimateContractExecutionFeeInput, type EstimateTransferFeeInput, type GetTokenInput, type GetTransactionInput, type GetWalletInput, type GetWalletNFTBalanceInput, type GetWalletSetInput, type GetWalletTokenBalanceInput, type ListTransactionsInput, type ListWalletSetsInput, type ListWalletsInput, type SignMessageInput, type SignTransactionInput, type SignTypedDataInput, type StoredData, type TokenAddressAndBlockchainInput, type TokenIdInput, type TokenInfo, type UpdateWalletInput, type UpdateWalletSetInput, type ValidateAddressInput, defaultBaseUrl, initiateDeveloperControlledWalletsClient };
